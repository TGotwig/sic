use pest::iterators::Pairs;
// Allow Parser import, without warning, since it will be generated by a macro.
use image::DynamicImage;
#[allow(unused_imports)]
use pest::Parser;

use std::path::Path;
use std::rc::Rc;

mod apply_operations;

// ensure grammar refreshes on compile
const _GRAMMAR: &str = include_str!("grammar.pest");
const PARSER_RULE: Rule = Rule::main;

#[derive(Parser)]
#[grammar = "operations/grammar.pest"]
struct SICParser;

#[derive(Debug, PartialEq)]
pub enum Operation {
    Blur(u32),
    FlipHorizontal,
    FlipVertical,
    Resize(u32, u32),
}

pub fn parse_and_apply_script(image: DynamicImage, script: &str) -> Result<DynamicImage, String> {
    let parsed_script = SICParser::parse(PARSER_RULE, script);
    let rule_pairs: Pairs<Rule> = parsed_script
        .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
    let operations: Vec<Operation> = parse_image_operations(rule_pairs);
    let result = apply_operations::apply_operations_on_image(Rc::new(image), operations);

    match result {
        Ok(rc) => {
            let unwrapped_dyn_image =
                Rc::try_unwrap(rc).unwrap_or_else(|_| panic!("Unable to get resulting image."));
            Ok(unwrapped_dyn_image)
        }
        Err(msg) => Err(format!("Unable to parse and apply: {}", msg)),
    }
}

// TODO: proper unwrap() handling
pub fn parse_image_operations(pairs: Pairs<Rule>) -> Vec<Operation> {
    pairs
        .map(|pair| match pair.as_rule() {
            Rule::blur => {
                let extract_num = pair
                    .into_inner()
                    .next()
                    .unwrap()
                    .as_str()
                    .parse::<u32>()
                    .unwrap();
                Operation::Blur(extract_num)
            }
            Rule::flip_horizontal => Operation::FlipHorizontal,
            Rule::flip_vertical => Operation::FlipVertical,
            Rule::resize => {
                let inner = pair.into_inner();
                let extract_x = inner
                    .clone()
                    .nth(0)
                    .unwrap()
                    .as_str()
                    .parse::<u32>()
                    .unwrap();
                let extract_y = inner
                    .clone()
                    .nth(1)
                    .unwrap()
                    .as_str()
                    .parse::<u32>()
                    .unwrap();
                Operation::Resize(extract_x, extract_y)
            }
            _ => unreachable!(),
        }).collect::<Vec<_>>()
}

#[cfg(test)]
mod tests {
    use super::*;

    const _TEST_IMAGE_PATH: &str = "resources/unsplash_763569_cropped.jpg";

    fn _setup() -> DynamicImage {
        image::open(&Path::new(_TEST_IMAGE_PATH)).unwrap()
    }

    fn _manual_inspection(img: &DynamicImage, path: &str) {
        if !cfg!(feature = "dont-run-on-ci") {
            let _ = img.save(path);
        }
    }

    #[test]
    fn test_multi_parse_and_apply_script() {
        let image = _setup();
        let script: &str = "flip_horizontal; resize 100 100; blur 3;";

        let result = parse_and_apply_script(image, script);

        assert!(result.is_ok());

        let _ = _manual_inspection(&result.unwrap(), "target/parse_util_apply_all.png");
    }

    #[test]
    fn test_blur_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "blur 15;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(vec![Operation::Blur(15)], parse_image_operations(pairs));
    }

    #[test]
    fn test_flip_horizontal_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "flip_horizontal;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            vec![Operation::FlipHorizontal],
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_flip_vertical_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "flip_vertical;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(vec![Operation::FlipVertical], parse_image_operations(pairs));
    }

    #[test]
    fn test_resize_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "resize 99 88;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            vec![Operation::Resize(99, 88)],
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_stmt_parse_correct() {
        let pairs = SICParser::parse(
            Rule::main,
            "blur 10;flip_horizontal;flip_vertical;resize 100 200;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            vec![
                Operation::Blur(10),
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200)
            ],
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_stmt_parse_diff_order_correct() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal;flip_vertical;resize 100 200;blur 10;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ],
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_whitespace() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal; flip_vertical; resize 100 200; blur 10;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ],
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_whitespace_2() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal    ; flip_vertical   ;   \t\t resize 100 200; blur 10;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ],
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_whitespace_3() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal;\nflip_vertical;\nresize 100 200;\n\tblur 10;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ],
            parse_image_operations(pairs)
        );
    }

    #[test]
    #[should_panic]
    fn test_multi_should_end_with_sep() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal; flip_vertical; resize 100 200; blur 10",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ],
            parse_image_operations(pairs)
        );
    }
}
