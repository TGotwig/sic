use pest::iterators::Pairs;

use super::{Operation, Operations, Rule};

// This function has been reworked to include error handling.
// Some errors should never happen because the parser generated by Pest should catch them already.
// Nevertheless, to guard against mistakes, error handling is now included.
// >> This function has several unwraps which should not be able to fail.
// >> The reason for this is that the pest grammar would not allow SICParse::parse() to succeed.
// >> This does assume that the grammar is correct... ;).
// >> Not grammatical constraints should be tested for and that's why this function
// >>  does return a Result.
// >> Perhaps not unwrapping on every pair could be implemented in the future, but for now,
// >>  the code will use unwrap to not become to awkward.
// >> The Pest book describes usage of unwrap as idiomatic [1].
//
// >> Possible missteps:
// >> - u32 out of bounds (the grammar describes "infinite unsigned integers")
// >> - repetition of sub rules (not known at compile time (this should be checked)
//
//
// [1] https://pest-parser.github.io/book/parser_api.html
pub fn parse_image_operations(pairs: Pairs<Rule>) -> Result<Operations, String> {
    pairs
        .map(|pair| match pair.as_rule() {
            Rule::blur => {
                let u_int_text = pair
                    .into_inner()
                    .next()
                    .ok_or_else(|| "Unable to parse `blur` value.".to_string())
                    .map(|val| val.as_str());

                let u_int =
                    u_int_text.and_then(|it: &str| it.parse::<u32>().map_err(|e| e.to_string()));

                u_int.map(|u| Operation::Blur(u))
            }
            Rule::brighten => {
                let int_text = pair
                    .into_inner()
                    .next()
                    .ok_or_else(|| "Unable to parse `brighten` value.".to_string())
                    .map(|val| val.as_str());

                let int =
                    int_text.and_then(|it: &str| it.parse::<i32>().map_err(|e| e.to_string()));

                int.map(|i| Operation::Brighten(i))
            }
            Rule::flip_horizontal => Ok(Operation::FlipHorizontal),
            Rule::flip_vertical => Ok(Operation::FlipVertical),
            Rule::huerotate => {
                let int_text = pair
                    .into_inner()
                    .next()
                    .ok_or_else(|| "Unable to parse `brighten` value.".to_string())
                    .map(|val| val.as_str());

                let int =
                    int_text.and_then(|it: &str| it.parse::<i32>().map_err(|e| e.to_string()));

                int.map(|i| Operation::HueRotate(i))
            }
            Rule::resize => {
                let mut inner = pair.into_inner();

                let x_text = inner
                    .next()
                    .ok_or_else(|| "Unable to parse `resize <x> <y>`".to_string())
                    .map(|val| val.as_str());

                let x = x_text.and_then(|it: &str| it.parse::<u32>().map_err(|e| e.to_string()));

                let y_text = inner
                    .next()
                    .ok_or_else(|| "Unable to parse `resize <x> <y>`".to_string())
                    .map(|val| val.as_str());

                let y = y_text.and_then(|it: &str| it.parse::<u32>().map_err(|e| e.to_string()));

                x.and_then(|ux| y.map(|uy| Operation::Resize(ux, uy)))
            }
            Rule::rotate90 => Ok(Operation::Rotate90),
            Rule::rotate180 => Ok(Operation::Rotate180),
            Rule::rotate270 => Ok(Operation::Rotate270),
            _ => Err("Parse failed: Operation doesn't exist".to_string()),
        }).collect::<Result<Operations, String>>()
}

#[cfg(test)]
mod tests {
    use super::*;
    use operations::SICParser;
    use pest::Parser;

    #[test]
    fn test_blur_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "blur 15;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(Ok(vec![Operation::Blur(15)]), parse_image_operations(pairs));
    }

    #[test]
    fn test_brighten_pos_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "brighten 3579;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::Brighten(3579)]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_brighten_neg_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "brighten -3579;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::Brighten(-3579)]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_flip_horizontal_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "flip_horizontal;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::FlipHorizontal]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_flip_vertical_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "flip_vertical;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::FlipVertical]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_hue_rotate_pos_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "huerotate 3579;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::HueRotate(3579)]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_hue_rotate_neg_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "huerotate -3579;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::HueRotate(-3579)]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_resize_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "resize 99 88;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::Resize(99, 88)]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_rotate90_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "rotate90;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(Ok(vec![Operation::Rotate90]), parse_image_operations(pairs));
    }

    #[test]
    fn test_rotate180_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "rotate180;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::Rotate180]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_rotate270_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "rotate270;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::Rotate270]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_stmt_parse_correct() {
        let pairs = SICParser::parse(
            Rule::main,
            "blur 10;flip_horizontal;flip_vertical;resize 100 200;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::Blur(10),
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200)
            ]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_stmt_parse_diff_order_correct() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal;flip_vertical;resize 100 200;blur 10;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_whitespace() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal; flip_vertical; resize 100 200; blur 10;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_whitespace_2() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal    ; flip_vertical   ;   \t\t resize 100 200; blur 10;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_whitespace_3() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal;\nflip_vertical;\nresize 100 200;\n\tblur 10;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_should_no_longer_end_with_sep() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal; flip_vertical; resize 100 200; blur 10",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_sep_optional() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal flip_vertical; resize 100 200 blur 10",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ]),
            parse_image_operations(pairs)
        );
    }

}
