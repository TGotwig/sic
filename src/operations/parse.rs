use pest::iterators::{Pair, Pairs};

use super::{Operation, Operations, Rule};

// This function has been reworked to include error handling.
// Some errors should never happen because the parser generated by Pest should catch them already.
// Nevertheless, to guard against mistakes, error handling is now included.
// >> This function has several unwraps which should not be able to fail.
// >> The reason for this is that the pest grammar would not allow SICParse::parse() to succeed.
// >> This does assume that the grammar is correct... ;).
// >> Not grammatical constraints should be tested for and that's why this function
// >>  does return a Result.
// >> Perhaps not unwrapping on every pair could be implemented in the future, but for now,
// >>  the code will use unwrap to not become to awkward.
// >> The Pest book describes usage of unwrap as idiomatic [1].
//
// >> Possible missteps:
// >> - u32 out of bounds (the grammar describes "infinite unsigned integers")
// >> - repetition of sub rules (not known at compile time (this should be checked)
//
//
// [1] https://pest-parser.github.io/book/parser_api.html
pub fn parse_image_operations(pairs: Pairs<Rule>) -> Result<Operations, String> {
    pairs
        .map(|pair| match pair.as_rule() {
            Rule::blur => parse_unop_u32(pair).map(|u| Operation::Blur(u)),
            Rule::brighten => parse_unop_i32(pair).map(|i| Operation::Brighten(i)),
            Rule::contrast => parse_unop_f32(pair).map(|f| Operation::Contrast(f)),
            Rule::flip_horizontal => Ok(Operation::FlipHorizontal),
            Rule::flip_vertical => Ok(Operation::FlipVertical),
            Rule::huerotate => parse_unop_i32(pair).map(|i| Operation::HueRotate(i)),
            Rule::resize => {
                let (x, y) = parse_binop_u32(pair);
                x.and_then(|ux| y.map(|uy| Operation::Resize(ux, uy)))
            }
            Rule::rotate90 => Ok(Operation::Rotate90),
            Rule::rotate180 => Ok(Operation::Rotate180),
            Rule::rotate270 => Ok(Operation::Rotate270),
            _ => Err("Parse failed: Operation doesn't exist".to_string()),
        }).collect::<Result<Operations, String>>()
}

// generalizing this to T would be nice, but delivered me a lot of headaches. Using this for now.
fn parse_unop_u32(pair: Pair<Rule>) -> Result<u32, String> {
    let mut inner = pair.into_inner();

    inner
        .next()
        .ok_or_else(|| format!("Unable to parse {}, too many arguments: {}", inner, 1))
        .map(|val| val.as_str())
        .and_then(|it: &str| it.parse::<u32>().map_err(|err| err.to_string()))
}

fn parse_unop_f32(pair: Pair<Rule>) -> Result<f32, String> {
    let mut inner = pair.into_inner();

    inner
        .next()
        .ok_or_else(|| format!("Unable to parse {}, too many arguments: {}", inner, 1))
        .map(|val| val.as_str())
        .and_then(|it: &str| it.parse::<f32>().map_err(|err| err.to_string()))
}

fn parse_unop_i32(pair: Pair<Rule>) -> Result<i32, String> {
    pair.into_inner()
        .next()
        .ok_or_else(|| format!("Unable to parse UnOp::i32, Expected 2 arguments."))
        .map(|val| val.as_str())
        .and_then(|it: &str| it.parse::<i32>().map_err(|err| err.to_string()))
}

fn parse_binop_u32(pair: Pair<Rule>) -> (Result<u32, String>, Result<u32, String>) {
    let mut inner = pair.into_inner();

    let x_text = inner
        .next()
        .ok_or_else(|| "Unable to parse `resize <x> <y>`".to_string())
        .map(|val| val.as_str());

    let x = x_text.and_then(|it: &str| it.parse::<u32>().map_err(|err| err.to_string()));

    let y_text = inner
        .next()
        .ok_or_else(|| "Unable to parse `resize <x> <y>`".to_string())
        .map(|val| val.as_str());

    let y = y_text.and_then(|it: &str| it.parse::<u32>().map_err(|err| err.to_string()));

    (x, y)
}

#[cfg(test)]
mod tests {
    use super::*;
    use operations::SICParser;
    use pest::Parser;

    #[test]
    fn test_blur_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "blur 15;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(Ok(vec![Operation::Blur(15)]), parse_image_operations(pairs));
    }

    #[test]
    fn test_contrast_single_stmt_int_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "contrast 15;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(Ok(vec![Operation::Contrast(15.0)]), parse_image_operations(pairs));
    }

    #[test]
    fn test_contrast_single_stmt_f32_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "contrast 15.8;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(Ok(vec![Operation::Contrast(15.8)]), parse_image_operations(pairs));
    }

    #[test]
    fn test_contrast_single_stmt_parse_fail_end_in_dot() {
        let pairs = SICParser::parse(Rule::main, "contrast 15.;");
        assert!(pairs.is_err());
    }

    #[test]
    fn test_contrast_single_stmt_parse_fail_max_f32_1() {
        let pairs = SICParser::parse(Rule::main, "340282200000000000000000000000000000000.0;");
        assert!(pairs.is_err());
    }


    #[test]
    fn test_brighten_pos_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "brighten 3579;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::Brighten(3579)]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_brighten_neg_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "brighten -3579;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::Brighten(-3579)]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_flip_horizontal_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "flip_horizontal;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::FlipHorizontal]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_flip_vertical_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "flip_vertical;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::FlipVertical]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_hue_rotate_pos_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "huerotate 3579;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::HueRotate(3579)]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_hue_rotate_neg_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "huerotate -3579;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::HueRotate(-3579)]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_resize_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "resize 99 88;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::Resize(99, 88)]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_rotate90_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "rotate90;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(Ok(vec![Operation::Rotate90]), parse_image_operations(pairs));
    }

    #[test]
    fn test_rotate180_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "rotate180;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::Rotate180]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_rotate270_single_stmt_parse_correct() {
        let pairs = SICParser::parse(Rule::main, "rotate270;")
            .unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![Operation::Rotate270]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_stmt_parse_correct() {
        let pairs = SICParser::parse(
            Rule::main,
            "blur 10;flip_horizontal;flip_vertical;resize 100 200;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::Blur(10),
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200)
            ]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_stmt_parse_diff_order_correct() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal;flip_vertical;resize 100 200;blur 10;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_whitespace() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal; flip_vertical; resize 100 200; blur 10;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_whitespace_2() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal    ; flip_vertical   ;   \t\t resize 100 200; blur 10;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_whitespace_3() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal;\nflip_vertical;\nresize 100 200;\n\tblur 10;",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_should_no_longer_end_with_sep() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal; flip_vertical; resize 100 200; blur 10",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ]),
            parse_image_operations(pairs)
        );
    }

    #[test]
    fn test_multi_sep_optional() {
        let pairs = SICParser::parse(
            Rule::main,
            "flip_horizontal flip_vertical; resize 100 200 blur 10",
        ).unwrap_or_else(|e| panic!("Unable to parse sic image operations script: {:?}", e));
        assert_eq!(
            Ok(vec![
                Operation::FlipHorizontal,
                Operation::FlipVertical,
                Operation::Resize(100, 200),
                Operation::Blur(10)
            ]),
            parse_image_operations(pairs)
        );
    }

}
